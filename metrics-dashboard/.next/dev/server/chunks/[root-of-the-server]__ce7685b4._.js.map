{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/jessiewhite/Development/Tech_Screens/Tensorwave/sre-take-home-challenge-15dc00b/www/pages/api/test-rpc.ts"],"sourcesContent":["import type { NextApiRequest, NextApiResponse } from 'next';\nimport * as grpc from '@grpc/grpc-js';\nimport * as protoLoader from '@grpc/proto-loader';\nimport { promisify } from 'util';\nimport path from 'path';\n\n// Get the proto file path relative to the project root\n// process.cwd() in Next.js API routes is the www directory, so we need to go up one level\nconst PROTO_PATH = path.resolve(process.cwd(), '../proto/test/test.proto');\n\nconst packageDefinition = protoLoader.loadSync(PROTO_PATH, {\n  keepCase: true,\n  longs: String,\n  enums: String,\n  defaults: true,\n  oneofs: true,\n});\n\nconst { test } = grpc.loadPackageDefinition(packageDefinition) as any;\n\ntype TestClient = {\n  testMethod: (\n    request: { test_before: string },\n    callback: (error: any, response: { test_after: string }) => void\n  ) => void;\n};\n\ntype MetricsClient = {\n  getMetrics: (\n    request: { agent_id?: string; metric_name?: string; start_time?: number; end_time?: number },\n    callback: (error: any, response: { metrics: any[] }) => void\n  ) => void;\n  submitMetrics: (\n    request: { agent_id: string; metrics: any[] },\n    callback: (error: any, response: {}) => void\n  ) => void;\n};\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  if (req.method !== 'POST' && req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const client = new test.MetricsService(\n      process.env.SERVER_ADDRESS || '127.0.0.1:3000',\n      grpc.credentials.createInsecure()\n    ) as MetricsClient;\n\n    const { agent_id, metrics } = req.body;\n    const getMetrics = promisify(client.getMetrics.bind(client));\n    const postMetrics = promisify(client.submitMetrics.bind(client));\n\n    const getMetricsResponse = await getMetrics({});  // Get all metrics\n    const postMetricsResponse = await postMetrics({\n      agent_id: agent_id, metrics: metrics\n    });  // Post new \n\n    res.status(200).json({ metrics: getMetricsResponse.metrics });\n    console.log(getMetricsResponse.metrics);\n    res.status(200).json({ metrics: postMetricsResponse });\n  } catch (error) {\n    console.error('Error fetching metrics:', error);\n    res.status(500).json({ error: 'Failed to fetch metrics' });\n  }\n}\n\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;AACA;;;;;AAEA,uDAAuD;AACvD,0FAA0F;AAC1F,MAAM,aAAa,4GAAI,CAAC,OAAO,CAAC,QAAQ,GAAG,IAAI;AAE/C,MAAM,oBAAoB,uJAAoB,CAAC,YAAY;IACzD,UAAU;IACV,OAAO;IACP,OAAO;IACP,UAAU;IACV,QAAQ;AACV;AAEA,MAAM,EAAE,IAAI,EAAE,GAAG,0JAA0B,CAAC;AAoB7B,eAAe,QAC5B,GAAmB,EACnB,GAAoB;IAEpB,IAAI,IAAI,MAAM,KAAK,UAAU,IAAI,MAAM,KAAK,OAAO;QACjD,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAAqB;IAC5D;IAEA,IAAI;QACF,MAAM,SAAS,IAAI,KAAK,cAAc,CACpC,QAAQ,GAAG,CAAC,cAAc,IAAI,kBAC9B,gJAAgB,CAAC,cAAc;QAGjC,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG,IAAI,IAAI;QACtC,MAAM,aAAa,IAAA,8GAAS,EAAC,OAAO,UAAU,CAAC,IAAI,CAAC;QACpD,MAAM,cAAc,IAAA,8GAAS,EAAC,OAAO,aAAa,CAAC,IAAI,CAAC;QAExD,MAAM,qBAAqB,MAAM,WAAW,CAAC,IAAK,kBAAkB;QACpE,MAAM,sBAAsB,MAAM,YAAY;YAC5C,UAAU;YAAU,SAAS;QAC/B,IAAK,YAAY;QAEjB,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,SAAS,mBAAmB,OAAO;QAAC;QAC3D,QAAQ,GAAG,CAAC,mBAAmB,OAAO;QACtC,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,SAAS;QAAoB;IACtD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAA0B;IAC1D;AACF"}}]
}